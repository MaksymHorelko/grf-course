#include "NTL/ZZ.h"
#include <iostream>

using std::cout;
using std::endl;
using namespace NTL;

void decrypt(ZZ p, ZZ q, ZZ e, ZZ Mc)
{

    ZZ n, phi, d, Md, tmp, tmp1;

    // Обчислення n = p * q
    n = p * q;
    // Обчислення значення функції Ейлера phi(n) = (p - 1) * (q - 1)
    phi = (p - 1) * (q - 1);

    // Знаходження такого d, щоб d * e = 1 mod phi, d < phi (Зворотні за модулем)
    XGCD(tmp, d, tmp1, e, phi);
    d = (d % phi + phi) % phi;

    // Розшифрування повідомлення
    Md = PowerMod(Mc, d, n);
    cout << "Розшифроване повідомлення: Md = " << Md << " (" << NumBits(Md) << " біт)\n" << endl;
}

int main()
{
    ZZ p, q, e, Mc;

    // 10
    p = conv<ZZ>("19");
    q = conv<ZZ>("31");
    e = conv<ZZ>("19");
    Mc = conv<ZZ>("123");
    decrypt(p, q, e, Mc);

    // 100
    p = conv<ZZ>("955531012072577");
    q = conv<ZZ>("600126804274519 ");
    e = conv<ZZ>("546569 ");
    Mc = conv<ZZ>("550368164507588887130246608799");
    decrypt(p, q, e, Mc);

    // 4096
    p = conv<ZZ>("21970775692700225376649403849999425059213477470396316568466825382546188081214996826282759574116538761359724335333909031258227514978181340005910070087497642509376745889111513084983681810802335437478652217827531213443087291415978995431640992522618677111024983870448525979774054592108360152569494657018326733113918416239883708346467265517321659323870684044849462069224578928604689267508161594591268667794737777319512403844742155528134327915597367066916955764969091201865022072135278692972034050658730148374628731893147932656218687285503341197048054965492835182907954715507461521634237605513786449294702078968975395918489");
    q = conv<ZZ>("24099253324800716102350781772319711171632176232397321530102071723617045034585031775326701298203108804046826434933160835517152887216858452895121399008823017016716631758409073673809647362854184243894424481626381102512499050998124833559966410793273293329774600727259468570804092319769055304194670012693281793375293438648535983095538291169816452000815378152171902892285365562367838624254147444969962281034320267684459406112285205281614183488908084877426523083052303612470714553719697845702465055535333182693549460335970843172810913055825830989272483346580456075681637209110726601818206518956555831284633388658883805031507");
    e = conv<ZZ>("60407528787831144548749011459695454458937641375013511428415718660136527308769");
    Mc = conv<ZZ>("506853535483315852003954272824042207048842047004511645324086791266789103161918970285358365149839180329376195920644409148940248068880952173145334651419100065013390730564626052001902889659881364286210491871248361200305108570707915524663488486456196954944404558549541153363413270319824231349278018986676149386973375139907408596794806280943734478884688822712261500084521449412259091293309486091303582763588644545663399095081236810533826474713037051734427390857277508532526987564011314645605550132952385629847635206571808150247985580090457045990691388966545363901147215159399597101246852144619219742448101043192864432675886747756342922773991724376985716048028019754867403430513161972487043886743542468385956965482259823426198411650069032918111765220582358169456084303524792436659354393379957794134147682846019375130744204095430303754021596909236354425256981444404384672632552624087318059402460784912008491126197675353044143647386093982458790173272470043247596380491672592269723692712963136340268112309759268037940737823161849418983733408612944910872008482039895522429509694977215632552959333344374552893685809540040580994912345904364150172844612982142433991725763182593403821510708125397162530528920023868362186667484282054289976336609067");
    decrypt(p, q, e, Mc);

    getchar();
    return 0;
}